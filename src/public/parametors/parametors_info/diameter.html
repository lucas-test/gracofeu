<h1 id="diameter-undirected">Diameter (undirected)</h1>
<p>This algorithm computes the diameter of an undirected graph $G$, that is the <em>greatest distance between any pair of vertices</em> or, alternatively:</p>
<p>$$d(G) = max_{v\in V(G)} max_{u\in V(G)} d(u,v)$$</p>
<p>To compute the diameter, we use the <strong>Floyd Warshall</strong> algorithm (see pseudo-code below).  </p>
<p><strong>This parameter is not computed live.</strong></p>
<h2 id="inputoutput">Input/Output</h2>
<ul>
<li>Input: An undirected graph $G$ </li>
<li>Output: A number. Returns ∞ if $G$ is not connected.</li>
</ul>
<h2 id="pseudo-code">Pseudo Code</h2>
<pre><code>procedure Diameter(G: Graph): number

    let dist be a |V(G)| × |V(G)| array of minimum distances initialized to ∞ (infinity)

    for each edge (u, v) in A(G) do
        dist[u][v] ← w(u, v)  // The weight of the edge (u, v)
    for each vertex v in V(G) do
        dist[v][v] ← 0

    for each vertex k in V(G)
        for each vertex i in V(G)
            for each vertex j in V(G)
                if dist[i][j] &gt; dist[i][k] + dist[k][j] 
                    dist[i][j] ← dist[i][k] + dist[k][j]
                end if
            end for
        end for
    end for

    d ← 0

    for each vertex i in V(G)
        for each vertex j in V(G)
            if d &lt; dist[i][j]
                d ← d[i][j]
            end if
        end for
    end for

    return d
end procedure
</code></pre>
<h2 id="complexity">Complexity</h2>
<p>This implementation of the algorithm runs in $O(n^{3})$, where $n$ is the number of vertices.  </p>
<h2 id="example">Example</h2>
<p>TO DO</p>
<h2 id="comments">Comments</h2>
<p>For sparse graphs with non-negative edge weights, lower asymptotic complexity can be obtained by running Dijkstra&#39;s algorithm (using Fibonacci heaps) from each possible starting vertex  than running the Floyd–Warshall algorithm. </p>
<p>There are also known algorithms using fast matrix multiplication to speed up all-pairs shortest path computation in dense graphs, but these typically make extra assumptions on the edge weights (such as requiring them to be small integers). In addition, because of the high constant factors in their running time, they would only provide a speedup over the Floyd–Warshall algorithm for very large graphs. </p>
<h2 id="more-information">More information</h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Distance_(graph_theory)">Distance on Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm">Floyd Warshall algorithm on Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra&#39;a algorithm on Wikipedia</a></li>
</ul>
<h2 id="changes">Changes</h2>
<ul>
<li><strong>v1</strong> Initial implementation of Floyd Warshall algorithm</li>
</ul>
